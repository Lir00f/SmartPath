"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sequelize_1 = require("sequelize");
const default_value_parser_1 = __importDefault(require("./helpers/default-value-parser"));
const sql_type_converter_1 = __importDefault(require("./helpers/sql-type-converter"));
class Introspector {
    static async introspect(sequelize, logger) {
        const tableNamesAndSchemas = await this.getTableNames(sequelize);
        const validTableNames = tableNamesAndSchemas.filter(name => sequelize.getDialect() !== 'mssql' || !name.tableName.includes('.'));
        if (validTableNames.length < tableNamesAndSchemas.length) {
            const diff = tableNamesAndSchemas.filter(name => !validTableNames.includes(name));
            logger?.('Warn', `Skipping table(s): ${diff
                .map(tableNameAndSchema => `'${tableNameAndSchema.tableName}'`)
                .join(', ')}. MSSQL tables with dots are not supported`);
        }
        const promises = validTableNames.map(name => this.getTable(sequelize, logger, name));
        const tables = await Promise.all(promises);
        this.sanitizeInPlace(tables);
        return tables;
    }
    /** Get names of all tables in the public schema of the db */
    static async getTableNames(sequelize) {
        const tableIdentifiers = await sequelize
            .getQueryInterface()
            .showAllTables();
        const requestedSchema = sequelize.options.schema || this.getDefaultSchema(sequelize);
        // Sometimes sequelize returns only strings,
        // and sometimes objects with a tableName and schema property.
        // @see https://github.com/sequelize/sequelize/blob/main/src/dialects/mariadb/query.js#L295
        return (tableIdentifiers
            .map((tableIdentifier) => typeof tableIdentifier === 'string'
            ? { tableName: tableIdentifier, schema: requestedSchema }
            : {
                schema: tableIdentifier.schema || requestedSchema,
                tableName: tableIdentifier.tableName,
            })
            // MSSQL returns all tables, not filtered by schema
            .filter(identifier => identifier.schema === requestedSchema));
    }
    static getDefaultSchema(sequelize) {
        switch (sequelize.getDialect()) {
            case 'postgres':
                return 'public';
            case 'mssql':
                return 'dbo';
            // MariaDB returns the database name as "schema" in table identifiers
            case 'mariadb':
            case 'mysql':
                return sequelize.getDatabaseName();
            default:
                return undefined;
        }
    }
    static getTableIdentifier(tableIdentifier, sequelize) {
        switch (sequelize.getDialect()) {
            case 'postgres':
            case 'mssql':
            case 'sqlite':
                return tableIdentifier;
            case 'mariadb':
            case 'mysql':
            default:
                return { tableName: tableIdentifier.tableName };
        }
    }
    /** Instrospect a single table */
    static async getTable(sequelize, logger, tableIdentifier) {
        const queryInterface = sequelize.getQueryInterface();
        // Sequelize is not consistent in the way it handles table identifiers either when it returns
        // it, when it uses it internally, or when it is passed as an argument.
        // Plus it has some bugs with schema handling in postgresql that forces us to be sure that
        // the table identifier is correct on our side
        const tableIdentifierForQuery = Introspector.getTableIdentifier(tableIdentifier, sequelize);
        const [columnDescriptions, tableIndexes, tableReferences] = await Promise.all([
            queryInterface.describeTable(tableIdentifierForQuery),
            queryInterface.showIndex(tableIdentifierForQuery),
            queryInterface.getForeignKeyReferencesForTable(tableIdentifierForQuery),
        ]);
        await this.detectBrokenRelationship(tableIdentifierForQuery, sequelize, tableReferences, logger);
        const columns = await Promise.all(Object.entries(columnDescriptions).map(async ([name, description]) => {
            const references = tableReferences.filter(
            // There is a bug right now with sequelize on postgresql: returned association
            // are not filtered on the schema. So we have to filter them manually.
            // Should be fixed with Sequelize v7
            r => r.columnName === name && r.tableSchema === tableIdentifier.schema);
            const options = { name, description, references };
            return this.getColumn(sequelize, logger, tableIdentifier, options);
        }));
        return {
            name: tableIdentifierForQuery.tableName,
            schema: tableIdentifierForQuery.schema,
            columns: columns.filter(Boolean),
            unique: tableIndexes
                .filter(i => i.unique || i.primary)
                .map(i => i.fields.map(f => f.attribute)),
        };
    }
    static async getColumn(sequelize, logger, tableIdentifier, options) {
        const { name, description, references } = options;
        const dialect = sequelize.getDialect();
        const typeConverter = new sql_type_converter_1.default(sequelize);
        try {
            const type = await typeConverter.convert(tableIdentifier, name, description);
            const parser = new default_value_parser_1.default(dialect);
            // Workaround autoincrement flag not being properly set when using postgres
            const autoIncrement = Boolean(description.autoIncrement || description.defaultValue?.match?.(/^nextval\(.+\)$/));
            return {
                type,
                autoIncrement,
                defaultValue: autoIncrement ? null : parser.parse(description.defaultValue, type),
                isLiteralDefaultValue: autoIncrement
                    ? false
                    : parser.isLiteral(description.defaultValue, type),
                name,
                allowNull: description.allowNull,
                primaryKey: description.primaryKey,
                constraints: references.map(r => ({
                    table: r.referencedTableName,
                    column: r.referencedColumnName,
                })),
            };
        }
        catch (e) {
            logger?.('Warn', `Skipping column ${tableIdentifier.tableName}.${name} (${e.message})`);
        }
    }
    /**
     * Remove references to entities that are not present in the schema
     * (happens when we skip entities because of errors)
     */
    static sanitizeInPlace(tables) {
        for (const table of tables) {
            // Remove unique indexes which depennd on columns that are not present in the table.
            table.unique = table.unique.filter(unique => unique.every(column => table.columns.find(c => c.name === column)));
            for (const column of table.columns) {
                // Remove references to tables that are not present in the schema.
                column.constraints = column.constraints.filter(constraint => {
                    const refTable = tables.find(t => t.name === constraint.table);
                    const refColumn = refTable?.columns.find(c => c.name === constraint.column);
                    return refTable && refColumn;
                });
            }
        }
    }
    static async detectBrokenRelationship(tableIdentifier, sequelize, tableReferences, logger) {
        let constraintNamesForForeignKey = [];
        const dialect = sequelize.getDialect();
        if (dialect === 'sqlite') {
            constraintNamesForForeignKey = await sequelize.query(`SELECT "from" as constraint_name, :tableName as table_name
        from pragma_foreign_key_list(:tableName);`, {
                replacements: { tableName: tableIdentifier.tableName },
                type: sequelize_1.QueryTypes.SELECT,
            });
        }
        else {
            constraintNamesForForeignKey = await sequelize.query(`
        SELECT constraint_name, table_name
          FROM information_schema.table_constraints
          WHERE table_name = :tableName 
            AND constraint_type = 'FOREIGN KEY'
            AND (:schema IS NULL OR table_schema = :schema);
        `, {
                replacements: {
                    tableName: tableIdentifier.tableName,
                    schema: tableIdentifier.schema || null,
                },
                type: sequelize_1.QueryTypes.SELECT,
            });
        }
        this.logBrokenRelationship(constraintNamesForForeignKey, tableReferences, logger);
    }
    static logBrokenRelationship(constraintNamesForForeignKey, tableReferences, logger) {
        if (constraintNamesForForeignKey.length !== tableReferences.length) {
            const constraintNames = new Set(constraintNamesForForeignKey.map(c => ({ constraint_name: c.constraint_name, table_name: c.table_name })));
            tableReferences.forEach(({ constraintName }) => {
                constraintNames.forEach(obj => {
                    if (obj.constraint_name === constraintName) {
                        constraintNames.delete(obj);
                    }
                });
            });
            constraintNames.forEach(obj => {
                logger?.('Error', 
                // eslint-disable-next-line max-len
                `Failed to load constraints on relation '${obj.constraint_name}' on table '${obj.table_name}'. The relation will be ignored.`);
            });
        }
    }
}
exports.default = Introspector;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50cm9zcGVjdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludHJvc3BlY3Rpb24vaW50cm9zcGVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EseUNBQTJEO0FBRTNELDBGQUFnRTtBQUNoRSxzRkFBNEQ7QUFVNUQsTUFBcUIsWUFBWTtJQUMvQixNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFvQixFQUFFLE1BQWU7UUFDM0QsTUFBTSxvQkFBb0IsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBaUMsQ0FBQyxDQUFDO1FBQ3pGLE1BQU0sZUFBZSxHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FDakQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLEtBQUssT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQzVFLENBQUM7UUFFRixJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxFQUFFO1lBQ3hELE1BQU0sSUFBSSxHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2xGLE1BQU0sRUFBRSxDQUNOLE1BQU0sRUFDTixzQkFBc0IsSUFBSTtpQkFDdkIsR0FBRyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxJQUFJLGtCQUFrQixDQUFDLFNBQVMsR0FBRyxDQUFDO2lCQUM5RCxJQUFJLENBQUMsSUFBSSxDQUFDLDRDQUE0QyxDQUMxRCxDQUFDO1NBQ0g7UUFFRCxNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFD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