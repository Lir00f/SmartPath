"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const datasource_toolkit_1 = require("@forestadmin/datasource-toolkit");
const promises_1 = require("fs/promises");
class TypingGenerator {
    constructor(logger, options = {}) {
        this.logger = logger;
        this.options = {
            maxFieldsCount: 10000,
        };
        this.options.maxFieldsCount = options.maxFieldsCount ?? this.options.maxFieldsCount;
    }
    /**
     * Write types to disk at a given path.
     * This method read the file which is already there before overwriting so that customers
     * using equivalents to nodemon to not enter restart loops.
     */
    async updateTypesOnFileSystem(dataSource, typingsPath, typingsMaxDepth) {
        const newTypes = this.generateTypes(dataSource, typingsMaxDepth);
        let olderTypes = null;
        try {
            olderTypes = await (0, promises_1.readFile)(typingsPath, { encoding: 'utf-8' });
        }
        catch (e) {
            if (e.code === 'ENOENT')
                olderTypes = null;
            else
                throw e;
        }
        if (newTypes !== olderTypes) {
            await (0, promises_1.writeFile)(typingsPath, newTypes, { encoding: 'utf-8' });
        }
    }
    /**
     * Generates types on a string.
     */
    generateTypes(dataSource, maxDepth) {
        const collections = [...dataSource.collections].sort((a, b) => a.name.localeCompare(b.name));
        return [
            `/* eslint-disable */`,
            `import {`,
            `  CollectionCustomizer,`,
            `  TAggregation,`,
            `  TConditionTree,`,
            `  TPaginatedFilter,`,
            `  TPartialRow,`,
            `  TSortClause`,
            `} from '@forestadmin/agent';`,
            '',
            this.generateAliases(dataSource),
            '',
            'export type Schema = {',
            ...collections.map(collection => [
                `  '${collection.name}': {`,
                this.getRow(collection),
                this.getRelations(collection),
                this.getFlatRelations(collection, maxDepth),
                '  };',
            ].join(`\n`)),
            '};\n',
        ].join('\n');
    }
    generateAliases(dataSource) {
        return dataSource.collections
            .flatMap(collection => {
            const name = collection.name.slice(0, 1).toUpperCase() +
                collection.name.slice(1).replace(/(_|-)[a-z]/g, match => match.slice(1).toUpperCase());
            return [
                // eslint-disable-next-line max-len
                `export type ${name}Customizer = CollectionCustomizer<Schema, '${collection.name}'>;`,
                `export type ${name}Record = TPartialRow<Schema, '${collection.name}'>;`,
                `export type ${name}ConditionTree = TConditionTree<Schema, '${collection.name}'>;`,
                `export type ${name}Filter = TPaginatedFilter<Schema, '${collection.name}'>;`,
                `export type ${name}SortClause = TSortClause<Schema, '${collection.name}'>;`,
                `export type ${name}Aggregation = TAggregation<Schema, '${collection.name}'>;`,
                '',
            ];
        })
            .join('\n');
    }
    getRow(collection) {
        const content = Object.entries(collection.schema.fields).reduce((memo, [name, field]) => {
            return field.type === 'Column' ? [...memo, `      '${name}': ${this.getType(field)};`] : memo;
        }, []);
        return `    plain: {\n${content.join('\n')}\n    };`;
    }
    getRelations(collection) {
        const content = Object.entries(collection.schema.fields).reduce((memo, [name, field]) => {
            if (field.type === 'ManyToOne' || field.type === 'OneToOne') {
                const relation = field.foreignCollection;
                return [
                    ...memo,
                    `      '${name}': Schema['${relation}']['plain'] & Schema['${relation}']['nested'];`,
                ];
            }
            return memo;
        }, []);
        return content.length ? `    nested: {\n${content.join('\n')}\n    };` : `    nested: {};`;
    }
    getFlatRelations(collection, maxDepth) {
        const fields = this.getFieldsOnCollection(collection, maxDepth);
        return fields.length
            ? `    flat: {\n      ${fields.join('\n      ')}\n    };`
            : `    flat: {};`;
    }
    getFieldsOnCollection(mainCollection, maxDepth) {
        const result = [];
        const queue = [{ collection: mainCollection, depth: 0, prefix: '', traversed: [] }];
        while (queue.length > 0 && result.length < this.options.maxFieldsCount) {
            const { collection, depth, prefix, traversed } = queue.shift();
            if (prefix) {
                result.push(...Object.entries(collection.schema.fields)
                    .filter(([, schema]) => schema.type === 'Column')
                    .map(([name, schema]) => `'${prefix}:${name}': ${this.getType(schema)};`));
            }
            if (depth < maxDepth) {
                queue.push(...Object.entries(collection.schema.fields)
                    .filter(([, schema]) => schema.type === 'ManyToOne' || schema.type === 'OneToOne')
                    .map(([name, schema]) => {
                    return {
                        subCollection: collection.dataSource.getCollection(schema.foreignCollection),
                        inverse: datasource_toolkit_1.CollectionUtils.getInverseRelation(collection, name),
                        name,
                        schema,
                    };
                })
                    .filter(({ subCollection, inverse }) => {
                    // Do not expand inverse relations, as those create useless cycles
                    return !traversed.find(({ c, r }) => c === subCollection && r === inverse);
                })
                    .map(({ subCollection, name }) => {
                    return {
                        collection: subCollection,
                        depth: depth + 1,
                        prefix: prefix ? `${prefix}:${name}` : name,
                        traversed: [...traversed, { c: collection, r: name }],
                    };
                }));
            }
        }
        if (queue.length || result.length >= this.options.maxFieldsCount) {
            this.logger?.('Warn', `Fields generation stopped on collection ${mainCollection.name}, ` +
                `try using a lower typingsMaxDepth (${maxDepth}) to avoid this issue.`);
        }
        return result.slice(0, this.options.maxFieldsCount);
    }
    getType(field) {
        if (Array.isArray(field.columnType)) {
            return `Array<${this.getType({
                columnType: field.columnType[0],
                enumValues: field.enumValues,
            })}>`;
        }
        if (field.columnType === 'Enum') {
            return field.enumValues?.map(v => `'${v.replace(/'/g, "\\'")}'`).join(' | ') ?? 'string';
        }
        if (typeof field.columnType === 'string') {
            return {
                Boolean: 'boolean',
                Binary: 'Buffer',
                Date: 'string',
                Dateonly: 'string',
                Json: 'any',
                Number: 'number',
                Point: '[number, number]',
                String: 'string',
                Time: 'string',
                Uuid: 'string',
            }[field.columnType];
        }
        return `{${Object.entries(field.columnType)
            .map(([key, subType]) => `${key}: ${this.getType({ columnType: subType })}`)
            .join('; ')}}`;
    }
}
exports.default = TypingGenerator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwaW5nLWdlbmVyYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy90eXBpbmctZ2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsd0VBTXlDO0FBQ3pDLDBDQUFrRDtBQUVsRCxNQUFxQixlQUFlO0lBS2xDLFlBQTZCLE1BQWMsRUFBRSxVQUF1QyxFQUFFO1FBQXpELFdBQU0sR0FBTixNQUFNLENBQVE7UUFKMUIsWUFBTyxHQUFHO1lBQ3pCLGNBQWMsRUFBRSxLQUFNO1NBQ3ZCLENBQUM7UUFHQSxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxPQUFPLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDO0lBQ3RGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLHVCQUF1QixDQUNsQyxVQUFzQixFQUN0QixXQUFtQixFQUNuQixlQUF1QjtRQUV2QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUNqRSxJQUFJLFVBQVUsR0FBa0IsSUFBSSxDQUFDO1FBRXJDLElBQUk7WUFDRixVQUFVLEdBQUcsTUFBTSxJQUFBLG1CQUFRLEVBQUMsV0FBVyxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDakU7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxRQUFRO2dCQUFFLFVBQVUsR0FBRyxJQUFJLENBQUM7O2dCQUN0QyxNQUFNLENBQUMsQ0FBQztTQUNkO1FBRUQsSUFBSSxRQUFRLEtBQUssVUFBVSxFQUFFO1lBQzNCLE1BQU0sSUFBQSxvQkFBUyxFQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUMvRDtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNJLGFBQWEsQ0FBQyxVQUFzQixFQUFFLFFBQWdCO1FBQzNELE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFN0YsT0FBTztZQUNMLHNCQUFzQjtZQUN0QixVQUFVO1lBQ1YseUJBQXlCO1lBQ3pCLGlCQUFpQjtZQUNqQixtQkFBbUI7WUFDbkIscUJBQXFCO1lBQ3JCLGdCQUFnQjtZQUNoQixlQUFlO1lBQ2YsOEJBQThCO1lBQzlCLEVBQUU7WUFDRixJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQztZQUNoQyxFQUFFO1lBQ0Ysd0JBQXdCO1lBQ3hCLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUM5QjtnQkFDRSxNQUFNLFVBQVUsQ0FBQyxJQUFJLE1BQU07Z0JBQzNCLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDO2dCQUN2QixJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQztnQkFDN0IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUM7Z0JBQzNDLE1BQU07YUFDUCxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDYjtZQUNELE1BQU07U0FDUCxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNmLENBQUM7SUFFTyxlQUFlLENBQUMsVUFBc0I7UUFDNUMsT0FBTyxVQUFVLENBQUMsV0FBVzthQUMxQixPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDcEIsTUFBTSxJQUFJLEdBQ1IsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRTtnQkFDekMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztZQUV6RixPQUFPO2dCQUNMLG1DQUFtQztnQkFDbkMsZUFBZSxJQUFJLDhDQUE4QyxVQUFVLENBQUMsSUFBSSxLQUFLO2dCQUNyRixlQUFlLElBQUksaUNBQWlDLFVBQVUsQ0FBQyxJQUFJLEtBQUs7Z0JBQ3hFLGVBQWUsSUFBSSwyQ0FBMkMsVUFBVSxDQUFDLElBQUksS0FBSztnQkFDbEYsZUFBZSxJQUFJLHNDQUFzQyxVQUFVLENBQUMsSUFBSSxLQUFLO2dCQUM3RSxlQUFlLElBQUkscUNBQXFDLFVBQVUsQ0FBQyxJQUFJLEtBQUs7Z0JBQzVFLGVBQWUsSUFBSSx1Q0FBdUMsVUFBVSxDQUFDLElBQUksS0FBSztnQkFDOUUsRUFBRTthQUNILENBQUM7UUFDSixDQUFDLENBQUM7YUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEIsQ0FBQztJQUVPLE1BQU0sQ0FBQyxVQUFzQjtRQUNuQyxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDdEYsT0FBTyxLQUFLLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBRSxVQUFVLElBQUksTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ2hHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQLE9BQU8saUJBQWlCLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN2RCxDQUFDO0lBRU8sWUFBWSxDQUFDLFVBQXNCO1FBQ3pDLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUN0RixJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssV0FBVyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssVUFBVSxFQUFFO2dCQUMzRCxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsaUJBQWlCLENBQUM7Z0JBRXpDLE9BQU87b0JBQ0wsR0FBRyxJQUFJO29CQUNQLFVBQVUsSUFBSSxjQUFjLFFBQVEseUJBQXlCLFFBQVEsZUFBZTtpQkFDckYsQ0FBQzthQUNIO1lBRUQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFUCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDO0lBQzdGLENBQUM7SUFFTyxnQkFBZ0IsQ0FBQyxVQUFzQixFQUFFLFFBQWdCO1FBQy9ELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFaEUsT0FBTyxNQUFNLENBQUMsTUFBTTtZQUNsQixDQUFDLENBQUMsc0JBQXNCLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVU7WUFDekQsQ0FBQyxDQUFDLGVBQWUsQ0FBQztJQUN0QixDQUFDO0lBRU8scUJBQXFCLENBQUMsY0FBMEIsRUFBRSxRQUFnQjtRQUN4RSxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFFbEIsTUFBTSxLQUFLLEdBQUcsQ0FBQyxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXBGLE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTtZQUN0RSxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRS9ELElBQUksTUFBTSxFQUFFO2dCQUNWLE1BQU0sQ0FBQyxJQUFJLENBQ1QsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO3FCQUN4QyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDO3FCQUNoRCxHQUFHLENBQ0YsQ0FBQyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxNQUFNLElBQUksSUFBSSxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBc0IsQ0FBQyxHQUFHLENBQ3BGLENBQ0osQ0FBQzthQUNIO1lBRUQsSUFBSSxLQUFLLEdBQUcsUUFBUSxFQUFFO2dCQUNwQixLQUFLLENBQUMsSUFBSSxDQUNSLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztxQkFDeEMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBQztxQkFDakYsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUEyRCxFQUFFLEVBQUU7b0JBQ2hGLE9BQU87d0JBQ0wsYUFBYSxFQUFFLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQzt3QkFDNUUsT0FBTyxFQUFFLG9DQUFlLENBQUMsa0JBQWtCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQzt3QkFDN0QsSUFBSTt3QkFDSixNQUFNO3FCQUNQLENBQUM7Z0JBQ0osQ0FBQyxDQUFDO3FCQUNELE1BQU0sQ0FBQyxDQUFDLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7b0JBQ3JDLGtFQUFrRTtvQkFDbEUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLGFBQWEsSUFBSSxDQUFDLEtBQUssT0FBTyxDQUFDLENBQUM7Z0JBQzdFLENBQUMsQ0FBQztxQkFDRCxHQUFHLENBQUMsQ0FBQyxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFO29CQUMvQixPQUFPO3dCQUNMLFVBQVUsRUFBRSxhQUFhO3dCQUN6QixLQUFLLEVBQUUsS0FBSyxHQUFHLENBQUM7d0JBQ2hCLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJO3dCQUMzQyxTQUFTLEVBQUUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDO3FCQUN0RCxDQUFDO2dCQUNKLENBQUMsQ0FBQyxDQUNMLENBQUM7YUFDSDtTQUNGO1FBRUQsSUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUU7WUFDaEUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUNYLE1BQU0sRUFDTiwyQ0FBMkMsY0FBYyxDQUFDLElBQUksSUFBSTtnQkFDaEUsc0NBQXNDLFFBQVEsd0JBQXdCLENBQ3pFLENBQUM7U0FDSDtRQUVELE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRU8sT0FBTyxDQUFDLEtBQXdEO1FBQ3RFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDbkMsT0FBTyxTQUFTLElBQUksQ0FBQyxPQUFPLENBQUM7Z0JBQzNCLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztnQkFDL0IsVUFBVSxFQUFFLEtBQUssQ0FBQyxVQUFVO2FBQzdCLENBQUMsR0FBRyxDQUFDO1NBQ1A7UUFFRCxJQUFJLEtBQUssQ0FBQyxVQUFVLEtBQUssTUFBTSxFQUFFO1lBQy9CLE9BQU8sS0FBSyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDO1NBQzFGO1FBRUQsSUFBSSxPQUFPLEtBQUssQ0FBQyxVQUFVLEtBQUssUUFBUSxFQUFFO1lBQ3hDLE9BQU87Z0JBQ0wsT0FBTyxFQUFFLFNBQVM7Z0JBQ2xCLE1BQU0sRUFBRSxRQUFRO2dCQUNoQixJQUFJLEVBQUUsUUFBUTtnQkFDZCxRQUFRLEVBQUUsUUFBUTtnQkFDbEIsSUFBSSxFQUFFLEtBQUs7Z0JBQ1gsTUFBTSxFQUFFLFFBQVE7Z0JBQ2hCLEtBQUssRUFBRSxrQkFBa0I7Z0JBQ3pCLE1BQU0sRUFBRSxRQUFRO2dCQUNoQixJQUFJLEVBQUUsUUFBUTtnQkFDZCxJQUFJLEVBQUUsUUFBUTthQUNmLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3JCO1FBRUQsT0FBTyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQzthQUN4QyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUM7YUFDM0UsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDbkIsQ0FBQztDQUNGO0FBak5ELGtDQWlOQyJ9